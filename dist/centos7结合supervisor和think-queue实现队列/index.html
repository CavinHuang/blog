<!DOCTYPE html><html lang=zh><head><meta charset=UTF-8><meta name=baidu-site-verification content=rqskM4bdtP><meta name=viewport content="device-width, initial-scale=1, maximum-scale=1,user-scalable=no"><title>centos7结合supervisor和think-queue实现队列-CavinHuang-不懂写故事的猫-http://blog.zukmb.cn</title><meta name=keywords content=前端学习,php学习,个人博客,HTML,CSS,JS><meta name=description content=cavinHuang个人博客，这里记录学习和生活的点滴！><meta name=google-site-verification content=zOYxWUgmeogC0qY76WLP0eWl8r9E8jk_qU927Ij7tbs><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5a4c3745fa28006f"></script><link rel=stylesheet href=/css/yoyo.css><link rel=icon href=/img/favicon.png><link rel=stylesheet href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css?version=1.3"><script src=//cdn.bootcss.com/jquery/3.2.1/jquery.min.js></script><script src=//cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js></script><script src=https://cdn.bootcss.com/velocity/1.5.0/velocity.min.js></script></head><body></body></html><div class=app><div class=left-container><canvas id=cas></canvas><div class="left-layout-container pc"><div class=user-info><a href="/"><img src="https://avatars1.githubusercontent.com/u/24950299?s=460&amp;v=4"></a><div class=login-name>CavinHuang</div><div class=slog>来不及总结自己,愿天大地大,我独一无二!</div></div><ul class=other-site><li><img src=http://www.17sucai.com/preview/177065/2017-09-28/Mon9/static/img/github.png></li><li><img src=http://www.17sucai.com/preview/177065/2017-09-28/Mon9/static/img/weibo.png></li></ul><ul class=left-menu><li><a href=/archives>文章</a></li><li><a href=/categories>分类</a></li><li><a href=/tags>标签</a></li><li><a href=/about>关于</a></li></ul><div class=qq-group><span>读万卷书</span><span>行万里路</span></div><div class=copyright>@ 2017 - 2017 CavinHuang</div></div></div><div class="blog-container main-container" id=content-outer><div class=blog-list-container id=content-inner><article class=article-container id=post><div class=article-header><h1 class=article-title>centos7结合supervisor和think-queue实现队列</h1><div class=article-subtitle><div class="publish-time fl">发布时间:<span>2017/9/15 9:2:20</span></div><div class=categories>分类:</div></div></div><div class=article-content><blockquote><p>Linux的后台进程运行有好几种方法，例如nohup，screen等，但是，如果是一个服务程序，要可靠地在后台运行，我们就需要把它做成daemon，最好还能监控进程状态，在意外结束时能自动重启。 supervisor就是用Python开发的一套通用的进程管理程序，能将一个普通的命令行进程变为后台daemon，并监控进程状态，异常退出时能自动重启。<br><a id=more></a></p><h1 id=安装supervisor><a href=#安装supervisor class=headerlink title=安装supervisor></a>安装supervisor</h1><p>【注】 linux环境必须安装 python</p></blockquote><h2 id=1-获取supervisor包：【https-pypi-python-org-pypi-supervisor】><a href=#1-获取supervisor包：【https-pypi-python-org-pypi-supervisor】 class=headerlink title=1.获取supervisor包：【https://pypi.python.org/pypi/supervisor】></a>1.获取supervisor包：【<a href=https://pypi.python.org/pypi/supervisor】 target=_blank rel=external>https://pypi.python.org/pypi/supervisor】</a></h2><figure class="highlight sh"><table><tr><td class=gutter><pre><div class=line>1</div></pre></td><td class=code><pre><div class=line>　　<span class=comment># wget https://pypi.python.org/packages/80/37/964c0d53cbd328796b1aeb7abea4c0f7b0e8c7197ea9b0b9967b7d004def/supervisor-3.3.1.tar.gz</span></div></pre></td></tr></table></figure><h2 id=2-解压supervisor-3-3-1-tar-gz-并安装><a href=#2-解压supervisor-3-3-1-tar-gz-并安装 class=headerlink title="2.解压supervisor-3.3.1.tar.gz 并安装"></a>2.解压supervisor-3.3.1.tar.gz 并安装</h2><figure class="highlight sh"><table><tr><td class=gutter><pre><div class=line>1</div><div class=line>2</div><div class=line>3</div></pre></td><td class=code><pre><div class=line>　　<span class=comment># tar zxvf supervisor-3.3.1.tar.gz &amp;&amp; cd supervisor-3.3.1</span></div><div class=line></div><div class=line>　　<span class=comment># python setup.py install</span></div></pre></td></tr></table></figure><p>【可能报错】：ImportError: No module named setuptools</p><p>【解决办法】：没有setuptools的模块，说明python缺少这个模块，那我们只要安装这个模块即可解决此问题</p><figure class="highlight sh"><table><tr><td class=gutter><pre><div class=line>1</div><div class=line>2</div><div class=line>3</div><div class=line>4</div><div class=line>5</div><div class=line>6</div><div class=line>7</div></pre></td><td class=code><pre><div class=line> 　　　　　　<span class=comment># wget http://pypi.python.org/packages/source/s/setuptools/setuptools-0.6c11.tar.gz</span></div><div class=line></div><div class=line>　　　　　　 <span class=comment># tar zxvf setuptools-0.6c11.tar.gz &amp;&amp; cd setuptools-0.6c11</span></div><div class=line></div><div class=line>　　　　　　 <span class=comment># python setup.py build</span></div><div class=line></div><div class=line>　　　　　　<span class=comment># python setup.py install</span></div></pre></td></tr></table></figure><h2 id=3-创建supervisor的配置文件：><a href=#3-创建supervisor的配置文件： class=headerlink title=3.创建supervisor的配置文件：></a>3.创建supervisor的配置文件：</h2><figure class="highlight sh"><table><tr><td class=gutter><pre><div class=line>1</div></pre></td><td class=code><pre><div class=line>　　<span class=comment># echo_supervisord_conf &gt; /etc/supervisord.conf</span></div></pre></td></tr></table></figure><h2 id=4-开启supervisord服务><a href=#4-开启supervisord服务 class=headerlink title=4.开启supervisord服务></a>4.开启supervisord服务</h2><figure class="highlight sh"><table><tr><td class=gutter><pre><div class=line>1</div></pre></td><td class=code><pre><div class=line>　　<span class=comment># supervisord -c /etc/supervisord.conf</span></div></pre></td></tr></table></figure><h2 id=5-更新新的配置到supervisord><a href=#5-更新新的配置到supervisord class=headerlink title=5.更新新的配置到supervisord></a>5.更新新的配置到supervisord</h2><figure class="highlight sh"><table><tr><td class=gutter><pre><div class=line>1</div></pre></td><td class=code><pre><div class=line>　　<span class=comment># supervisorctl update</span></div></pre></td></tr></table></figure><h2 id=6-重新启动配置中的所有程序><a href=#6-重新启动配置中的所有程序 class=headerlink title=6.重新启动配置中的所有程序></a>6.重新启动配置中的所有程序</h2><figure class="highlight sh"><table><tr><td class=gutter><pre><div class=line>1</div></pre></td><td class=code><pre><div class=line>　　<span class=comment># supervisorctl reload</span></div></pre></td></tr></table></figure><h2 id=7-启动某个进程-program-name-你配置中写的程序名称><a href=#7-启动某个进程-program-name-你配置中写的程序名称 class=headerlink title="7.启动某个进程(program_name=你配置中写的程序名称)"></a>7.启动某个进程(program_name=你配置中写的程序名称)</h2><figure class="highlight sh"><table><tr><td class=gutter><pre><div class=line>1</div></pre></td><td class=code><pre><div class=line>　　<span class=comment># supervisorctl start program_name</span></div></pre></td></tr></table></figure><h2 id=8-查看正在守候的进程><a href=#8-查看正在守候的进程 class=headerlink title=8.查看正在守候的进程></a>8.查看正在守候的进程</h2><figure class="highlight sh"><table><tr><td class=gutter><pre><div class=line>1</div></pre></td><td class=code><pre><div class=line>　　<span class=comment># supervisorctl</span></div></pre></td></tr></table></figure><h2 id=9-重启某一进程-program-name-你配置中写的程序名称><a href=#9-重启某一进程-program-name-你配置中写的程序名称 class=headerlink title="9.重启某一进程 (program_name=你配置中写的程序名称)"></a>9.重启某一进程 (program_name=你配置中写的程序名称)</h2><figure class="highlight sh"><table><tr><td class=gutter><pre><div class=line>1</div></pre></td><td class=code><pre><div class=line>　　<span class=comment># supervisorctl restart program_name</span></div></pre></td></tr></table></figure><h2 id=10-停止全部进程><a href=#10-停止全部进程 class=headerlink title=10.停止全部进程></a>10.停止全部进程</h2><figure class="highlight fortran"><table><tr><td class=gutter><pre><div class=line>1</div></pre></td><td class=code><pre><div class=line>　　# supervisorctl <span class=keyword>stop</span> <span class=built_in>all</span></div></pre></td></tr></table></figure><h2 id=11-查看supervisord进程><a href=#11-查看supervisord进程 class=headerlink title=11.查看supervisord进程></a>11.查看supervisord进程</h2><p><img src=/assets/blogimg/supervisorctl_sh.png&quot;进程&quot; alt=进程></p><hr><blockquote><p>传统的程序执行流程一般是 即时|同步|串行的，在某些场景下，会存在并发低，吞吐量低，响应时间长等问题。在大型系统中，一般会引入消息队列的组件，将流程中部分任务抽离出来放入消息队列，并由专门的消费者作针对性的处理，从而降低系统耦合度，提高系统性能和可用性。<br>一般来说，可以抽离的任务具有以下的特点：</p><ul><li><strong>允许延后|异步|并行处理</strong> （相对于传统的 <strong>即时|同步|串行</strong> 的执行方式）<ul><li><strong>允许延后</strong>：<br>抢购活动时，先快速缓冲有限的参与人数到消息队列，后续再排队处理实际的抢购业务；</li><li><strong>允许异步</strong>：<br>业务处理过程中的邮件，短信等通知</li><li><strong>允许并行</strong>：<br>用户支付成功之后，邮件通知，微信通知，短信通知可以由多个不同的消费者并行执行，通知到达的时间不要求先后顺序。</li></ul></li><li><strong>允许失败和重试</strong><ul><li>强一致性的业务放入核心流程处理</li><li>无一致性要求或最终一致即可的业务放入队列处理<br><strong><a href=https://github.com/top-think/think-queue/releases target=_blank rel=external>thinkphp-queue</a></strong> 是thinkphp 官方提供的一个消息队列服务，它支持消息队列的一些基本特性：</li></ul></li></ul></blockquote><ul><li>消息的<strong>发布</strong>，<strong>获取</strong>，<strong>执行</strong>，<strong>删除</strong>，<strong>重发</strong>，<strong>失败处理</strong>，<strong>延迟执行</strong>，<strong>超时控制</strong>等</li><li>队列的<strong>多队列</strong>， <strong>内存限制</strong> ，<strong>启动</strong>，<strong>停止</strong>，<strong>守护</strong>等</li><li>消息队列可<strong>降级为同步执行</strong></li></ul><p>thinkphp-queue 内置了 <strong>Redis</strong>，<strong>Database</strong>，<strong>Topthink</strong> ，<strong>Sync</strong>这四种驱动。本文主要介绍 thinkphp-queue 结合其内置的 redis 驱动的使用方式和基本原理。</p><p>注1：如无特殊说明，下文中的 ‘消息’ 和 ‘任务’两个词指代的是同一个概念，即队列中的一个成员。该成员对消息队列而言是其内部保存的消息； 对业务应用而言是一个待执行的任务。请根据语境区分。</p><p>注2：本文编写时(2017-02-15)使用的 thinkphp-queue 的版本号是 v1.1.2 。该版本中部分功能并未全部完成，如 subscribe 模式，以及存在几个bug(稍后会提及)。如有变更，请以官方最新版为准。</p><h3 id=一-代码示例><a href=#一-代码示例 class=headerlink title="一 代码示例"></a>一 代码示例</h3><p>先通过一段代码，了解一下 thinkphp-queue 的基本使用流程。</p><blockquote><p>目标：</p><p>在业务控制器中推送一个新消息到一个名为 ‘helloJobQueue’ 的队列中，该消息中包含我们自定义的业务数据，然后，编写一个名为 Hello 的消费者类，并通过命令行去调用该消费者类获取这个消息，拿到定义的数据。</p></blockquote><h1 id=安装-thinkphp-queue><a href=#安装-thinkphp-queue class=headerlink title="安装 thinkphp-queue"></a>安装 thinkphp-queue</h1><figure class="highlight bash"><table><tr><td class=gutter><pre><div class=line>1</div></pre></td><td class=code><pre><div class=line>composer install thinkphp-queue</div></pre></td></tr></table></figure><h2 id=搭建消息队列的存储环境><a href=#搭建消息队列的存储环境 class=headerlink title=搭建消息队列的存储环境></a>搭建消息队列的存储环境</h2><ul><li><p>使用 Redis [<strong>推荐</strong>]</p><figure class=highlight><table><tr><td class=gutter><pre><div class=line>1</div></pre></td><td class=code><pre><div class=line>安装并启动 Redis 服务</div></pre></td></tr></table></figure></li><li><p>使用数据库 [不推荐]</p><figure class="highlight plain"><table><tr><td class=gutter><pre><div class=line>1</div><div class=line>2</div><div class=line>3</div><div class=line>4</div><div class=line>5</div><div class=line>6</div><div class=line>7</div><div class=line>8</div><div class=line>9</div><div class=line>10</div><div class=line>11</div></pre></td><td class=code><pre><div class=line>CREATE TABLE `prefix_jobs` (</div><div class=line>  `id` int(11) NOT NULL AUTO_INCREMENT,</div><div class=line>  `queue` varchar(255) NOT NULL,</div><div class=line>  `payload` longtext NOT NULL,</div><div class=line>  `attempts` tinyint(3) unsigned NOT NULL,</div><div class=line>  `reserved` tinyint(3) unsigned NOT NULL,</div><div class=line>  `reserved_at` int(10) unsigned DEFAULT NULL,</div><div class=line>  `available_at` int(10) unsigned NOT NULL,</div><div class=line>  `created_at` int(10) unsigned NOT NULL,</div><div class=line>  PRIMARY KEY (`id`)</div><div class=line>) ENGINE=InnoDB DEFAULT CHARSET=utf8;</div></pre></td></tr></table></figure></li></ul><h2 id=配置消息队列的驱动><a href=#配置消息队列的驱动 class=headerlink title=配置消息队列的驱动></a>配置消息队列的驱动</h2><p>根据选择的存储方式，在 <code>\application\extra\queue.php</code> 这个配置文件中，添加消息队列对应的驱动配置</p><figure class="highlight php"><table><tr><td class=gutter><pre><div class=line>1</div><div class=line>2</div><div class=line>3</div><div class=line>4</div><div class=line>5</div><div class=line>6</div><div class=line>7</div><div class=line>8</div><div class=line>9</div><div class=line>10</div><div class=line>11</div><div class=line>12</div><div class=line>13</div><div class=line>14</div><div class=line>15</div><div class=line>16</div><div class=line>17</div><div class=line>18</div><div class=line>19</div><div class=line>20</div><div class=line>21</div><div class=line>22</div><div class=line>23</div><div class=line>24</div><div class=line>25</div><div class=line>26</div><div class=line>27</div><div class=line>28</div><div class=line>29</div></pre></td><td class=code><pre><div class=line><span class=keyword>return</span> [</div><div class=line>    <span class=string>'connector'</span>  =&gt; <span class=string>'Redis'</span>,            <span class=comment>// Redis 驱动</span></div><div class=line>    <span class=string>'expire'</span>     =&gt; <span class=number>60</span>,                <span class=comment>// 任务的过期时间，默认为60秒; 若要禁用，则设置为 null</span></div><div class=line>    <span class=string>'default'</span>    =&gt; <span class=string>'default'</span>,        <span class=comment>// 默认的队列名称</span></div><div class=line>    <span class=string>'host'</span>       =&gt; <span class=string>'127.0.0.1'</span>,        <span class=comment>// redis 主机ip</span></div><div class=line>    <span class=string>'port'</span>       =&gt; <span class=number>6379</span>,            <span class=comment>// redis 端口</span></div><div class=line>    <span class=string>'password'</span>   =&gt; <span class=string>''</span>,                <span class=comment>// redis 密码</span></div><div class=line>    <span class=string>'select'</span>     =&gt; <span class=number>0</span>,                <span class=comment>// 使用哪一个 db，默认为 db0</span></div><div class=line>    <span class=string>'timeout'</span>    =&gt; <span class=number>0</span>,                <span class=comment>// redis连接的超时时间</span></div><div class=line>    <span class=string>'persistent'</span> =&gt; <span class=keyword>false</span>,            <span class=comment>// 是否是长连接</span></div><div class=line></div><div class=line><span class=comment>//    'connector' =&gt; 'Database',   // 数据库驱动</span></div><div class=line><span class=comment>//    'expire'    =&gt; 60,           // 任务的过期时间，默认为60秒; 若要禁用，则设置为 null</span></div><div class=line><span class=comment>//    'default'   =&gt; 'default',    // 默认的队列名称</span></div><div class=line><span class=comment>//    'table'     =&gt; 'jobs',       // 存储消息的表名，不带前缀</span></div><div class=line><span class=comment>//    'dsn'       =&gt; [],</span></div><div class=line></div><div class=line><span class=comment>//    'connector'   =&gt; 'Topthink',    // ThinkPHP内部的队列通知服务平台 ，本文不作介绍</span></div><div class=line><span class=comment>//    'token'       =&gt; '',</span></div><div class=line><span class=comment>//    'project_id'  =&gt; '',</span></div><div class=line><span class=comment>//    'protocol'    =&gt; 'https',</span></div><div class=line><span class=comment>//    'host'        =&gt; 'qns.topthink.com',</span></div><div class=line><span class=comment>//    'port'        =&gt; 443,</span></div><div class=line><span class=comment>//    'api_version' =&gt; 1,</span></div><div class=line><span class=comment>//    'max_retries' =&gt; 3,</span></div><div class=line><span class=comment>//    'default'     =&gt; 'default',</span></div><div class=line></div><div class=line><span class=comment>//    'connector'   =&gt; 'Sync',        // Sync 驱动，该驱动的实际作用是取消消息队列，还原为同步执行</span></div><div class=line>];</div></pre></td></tr></table></figure><p><strong>1.3.1 配置文件中的 expire 参数说明</strong></p><p>expire 参数指的是任务的过期时间。 过期的任务，其准确的定义是</p><ol><li>任务的状态为执行中</li><li>任务的开始执行的时刻 + expire &gt; 当前时刻</li></ol><p>expire 不为<code>null</code> 时 ，thinkphp-queue 会在每次获取下一个任务之前检查并重发过期(执行超时)的任务。</p><p>expire 为<code>null</code> 时，thinkphp-queue 不会检查过期的任务，性能相对较高一点。但是需要注意：</p><ul><li>这些执行超时的任务会一直留在消息队列中，需要开发者另行处理(删除或者重发)！</li><li>[ <strong><a href=https://github.com/top-think/think-queue/issues/12 target=_blank rel=external>Bug</a></strong> ]在redis 驱动下，expire 设置为 null 时，无法实现任务的延迟执行! (Database 驱动下无影响)</li></ul><p><strong>对expire 参数理解或者使用不当时，很容易产生一些bug</strong>，后面会举例提到。</p><h3 id=消息的创建与推送><a href=#消息的创建与推送 class=headerlink title=消息的创建与推送></a>消息的创建与推送</h3><p>我们在业务控制器中创建一个新的消息，并推送到 <code>helloJobQueue</code> 队列</p><p>新增 <code>\application\index\controller\JobTest.php</code> 控制器，在该控制器中添加 <code>actionWithHelloJob</code> 方法</p><figure class="highlight php"><table><tr><td class=gutter><pre><div class=line>1</div><div class=line>2</div><div class=line>3</div><div class=line>4</div><div class=line>5</div><div class=line>6</div><div class=line>7</div><div class=line>8</div><div class=line>9</div><div class=line>10</div><div class=line>11</div><div class=line>12</div><div class=line>13</div><div class=line>14</div><div class=line>15</div><div class=line>16</div><div class=line>17</div><div class=line>18</div><div class=line>19</div><div class=line>20</div><div class=line>21</div><div class=line>22</div><div class=line>23</div><div class=line>24</div><div class=line>25</div><div class=line>26</div><div class=line>27</div><div class=line>28</div><div class=line>29</div><div class=line>30</div><div class=line>31</div><div class=line>32</div><div class=line>33</div><div class=line>34</div></pre></td><td class=code><pre><div class=line><span class=meta>&lt;?php</span></div><div class=line><span class=comment>/**</span></div><div class=line><span class=comment>* 文件路径： \application\index\controller\JobTest.php</span></div><div class=line><span class=comment>* 该控制器的业务代码中借助了thinkphp-queue 库，将一个消息推送到消息队列</span></div><div class=line><span class=comment>*/</span></div><div class=line><span class=keyword>namespace</span> <span class=title>application</span>\<span class=title>index</span>\<span class=title>controller</span>;</div><div class=line>  <span class=keyword>use</span> <span class=title>think</span>\<span class=title>Exception</span>;</div><div class=line></div><div class=line>  <span class=keyword>use</span> <span class=title>think</span>\<span class=title>Queue</span>;</div><div class=line></div><div class=line>  <span class=class><span class=keyword>class</span> <span class=title>JobTest</span> </span>&#123;</div><div class=line>  <span class=comment>/**</span></div><div class=line><span class=comment>   * 一个使用了队列的 action</span></div><div class=line><span class=comment>   */</span></div><div class=line>  <span class=keyword>public</span> <span class=function><span class=keyword>function</span> <span class=title>actionWithHelloJob</span><span class=params>()</span></span>&#123;</div><div class=line></div><div class=line>      <span class=comment>// 1.当前任务将由哪个类来负责处理。</span></div><div class=line>      <span class=comment>//   当轮到该任务时，系统将生成一个该类的实例，并调用其 fire 方法</span></div><div class=line>      $jobHandlerClassName  = <span class=string>'application\index\job\Hello'</span>;</div><div class=line>      <span class=comment>// 2.当前任务归属的队列名称，如果为新队列，会自动创建</span></div><div class=line>      $jobQueueName        = <span class=string>"helloJobQueue"</span>;</div><div class=line>      <span class=comment>// 3.当前任务所需的业务数据 . 不能为 resource 类型，其他类型最终将转化为json形式的字符串</span></div><div class=line>      <span class=comment>//   ( jobData 为对象时，需要在先在此处手动序列化，否则只存储其public属性的键值对)</span></div><div class=line>      $jobData             = [ <span class=string>'ts'</span> =&gt; time(), <span class=string>'bizId'</span> =&gt; uniqid() , <span class=string>'a'</span> =&gt; <span class=number>1</span> ] ;</div><div class=line>      <span class=comment>// 4.将该任务推送到消息队列，等待对应的消费者去执行</span></div><div class=line>      $isPushed = Queue::push( $jobHandlerClassName , $jobData , $jobQueueName );</div><div class=line>      <span class=comment>// database 驱动时，返回值为 1|false  ;   redis 驱动时，返回值为 随机字符串|false</span></div><div class=line>      <span class=keyword>if</span>( $isPushed !== <span class=keyword>false</span> )&#123;  </div><div class=line>          <span class=keyword>echo</span> date(<span class=string>'Y-m-d H:i:s'</span>) . <span class=string>" a new Hello Job is Pushed to the MQ"</span>.<span class=string>"&lt;br&gt;"</span>;</div><div class=line>      &#125;<span class=keyword>else</span>&#123;</div><div class=line>          <span class=keyword>echo</span> <span class=string>'Oops, something went wrong.'</span>;</div><div class=line>      &#125;</div><div class=line>  &#125;</div><div class=line> &#125;</div></pre></td></tr></table></figure><p><strong>注意:</strong> 在这个例子当中，我们是手动指定的 <code>$jobHandlerClassName</code> ，更合理的做法是先定义好消息名称与消费者类名的映射关系，然后由某个可以获取该映射关系的类来推送这个消息。这样，生产者只需要知道消息的名称，而无需指定哪个消费者类来处理。</p><blockquote><p>除了 <code>Queue::push( $jobHandlerClassName , $jobData , $jobQueueName );</code>这种方式之外，还可以直接传入 <code>Queue::push( $jobHandlerObject ,null , $jobQueueName );</code> 这时，需要在 $jobHandlerObject 中定义一个 <code>handle()</code> 方法，消息队列在执行到该任务时会自动反序列化该对象，并调用其 <code>handle()</code>方法。 该方式的缺点是无法传入自定义数据。</p></blockquote><h3 id=消息的消费与删除><a href=#消息的消费与删除 class=headerlink title=消息的消费与删除></a>消息的消费与删除</h3><p>编写 Hello 消费者类，用于处理 <code>helloJobQueue</code> 队列中的任务</p><p>新增 <code>\application\index\job\Hello.php</code> 消费者类，并编写其 <code>fire()</code> 方法</p><figure class="highlight php"><table><tr><td class=gutter><pre><div class=line>1</div><div class=line>2</div><div class=line>3</div><div class=line>4</div><div class=line>5</div><div class=line>6</div><div class=line>7</div><div class=line>8</div><div class=line>9</div><div class=line>10</div><div class=line>11</div><div class=line>12</div><div class=line>13</div><div class=line>14</div><div class=line>15</div><div class=line>16</div><div class=line>17</div><div class=line>18</div><div class=line>19</div><div class=line>20</div><div class=line>21</div><div class=line>22</div><div class=line>23</div><div class=line>24</div><div class=line>25</div><div class=line>26</div><div class=line>27</div><div class=line>28</div><div class=line>29</div><div class=line>30</div><div class=line>31</div><div class=line>32</div><div class=line>33</div><div class=line>34</div><div class=line>35</div><div class=line>36</div><div class=line>37</div><div class=line>38</div><div class=line>39</div><div class=line>40</div><div class=line>41</div><div class=line>42</div><div class=line>43</div><div class=line>44</div><div class=line>45</div><div class=line>46</div><div class=line>47</div><div class=line>48</div><div class=line>49</div><div class=line>50</div><div class=line>51</div></pre></td><td class=code><pre><div class=line><span class=meta>&lt;?php</span></div><div class=line> <span class=comment>/**</span></div><div class=line><span class=comment>  * 文件路径： \application\index\job\Hello.php</span></div><div class=line><span class=comment>  * 这是一个消费者类，用于处理 helloJobQueue 队列中的任务</span></div><div class=line><span class=comment>  */</span></div><div class=line> <span class=keyword>namespace</span> <span class=title>application</span>\<span class=title>index</span>\<span class=title>job</span>;</div><div class=line></div><div class=line> <span class=keyword>use</span> <span class=title>think</span>\<span class=title>queue</span>\<span class=title>Job</span>;</div><div class=line></div><div class=line> <span class=class><span class=keyword>class</span> <span class=title>Hello</span> </span>&#123;</div><div class=line></div><div class=line>     <span class=comment>/**</span></div><div class=line><span class=comment>      * fire方法是消息队列默认调用的方法</span></div><div class=line><span class=comment>      * <span class=doctag>@param</span> Job            $job      当前的任务对象</span></div><div class=line><span class=comment>      * <span class=doctag>@param</span> array|mixed    $data     发布任务时自定义的数据</span></div><div class=line><span class=comment>      */</span></div><div class=line>     <span class=keyword>public</span> <span class=function><span class=keyword>function</span> <span class=title>fire</span><span class=params>(Job $job,$data)</span></span>&#123;</div><div class=line></div><div class=line>         $isJobDone = <span class=keyword>$this</span>-&gt;doHelloJob($data);</div><div class=line></div><div class=line>         <span class=keyword>if</span> ($isJobDone) &#123;</div><div class=line>             <span class=comment>//如果任务执行成功， 记得删除任务</span></div><div class=line>             $job-&gt;delete();</div><div class=line>             <span class=keyword>print</span>(<span class=string>"&lt;info&gt;Hello Job has been done and deleted"</span>.<span class=string>"&lt;/info&gt;\n"</span>);</div><div class=line>         &#125;<span class=keyword>else</span>&#123;</div><div class=line>             <span class=keyword>if</span> ($job-&gt;attempts() &gt; <span class=number>3</span>) &#123;</div><div class=line>                 <span class=comment>//通过这个方法可以检查这个任务已经重试了几次了</span></div><div class=line>                 <span class=keyword>print</span>(<span class=string>"&lt;warn&gt;Hello Job has been retried more than 3 times!"</span>.<span class=string>"&lt;/warn&gt;\n"</span>);</div><div class=line>                 $job-&gt;delete();</div><div class=line>                 <span class=comment>// 也可以重新发布这个任务</span></div><div class=line>                 <span class=comment>//print("&lt;info&gt;Hello Job will be availabe again after 2s."."&lt;/info&gt;\n");</span></div><div class=line>                 <span class=comment>//$job-&gt;release(2); //$delay为延迟时间，表示该任务延迟2秒后再执行</span></div><div class=line>             &#125;</div><div class=line>         &#125;</div><div class=line>     &#125;</div><div class=line></div><div class=line>     <span class=comment>/**</span></div><div class=line><span class=comment>      * 根据消息中的数据进行实际的业务处理</span></div><div class=line><span class=comment>      * <span class=doctag>@param</span> array|mixed    $data     发布任务时自定义的数据</span></div><div class=line><span class=comment>      * <span class=doctag>@return</span> boolean                 任务执行的结果</span></div><div class=line><span class=comment>      */</span></div><div class=line>     <span class=keyword>private</span> <span class=function><span class=keyword>function</span> <span class=title>doHelloJob</span><span class=params>($data)</span> </span>&#123;</div><div class=line>         <span class=comment>// 根据消息中的数据进行实际的业务处理...</span></div><div class=line></div><div class=line>         <span class=keyword>print</span>(<span class=string>"&lt;info&gt;Hello Job Started. job Data is: "</span>.var_export($data,<span class=keyword>true</span>).<span class=string>"&lt;/info&gt; \n"</span>);</div><div class=line>         <span class=keyword>print</span>(<span class=string>"&lt;info&gt;Hello Job is Fired at "</span> . date(<span class=string>'Y-m-d H:i:s'</span>) .<span class=string>"&lt;/info&gt; \n"</span>);</div><div class=line>         <span class=keyword>print</span>(<span class=string>"&lt;info&gt;Hello Job is Done!"</span>.<span class=string>"&lt;/info&gt; \n"</span>);</div><div class=line></div><div class=line>         <span class=keyword>return</span> <span class=keyword>true</span>;</div><div class=line>     &#125;</div><div class=line> &#125;</div></pre></td></tr></table></figure><p>至此，所有的代码都已准备完毕，在运行消息队列之前，我们先看一下现在的目录结构：</p><p><img src=/目录结构-代码示例.png alt=目录结构-代码示例></p><h3 id=发布任务><a href=#发布任务 class=headerlink title=发布任务></a>发布任务</h3><p>在浏览器中访问 <a href=http://your.project.domain/index/job_test/actionWithHelloJob target=_blank rel=external>http://your.project.domain/index/job_test/actionWithHelloJob</a> ,可以看到消息推送成功。</p><p><img src=/浏览器提示消息推送结果.png alt=浏览器提示消息推送结果></p><h3 id=处理任务><a href=#处理任务 class=headerlink title=处理任务></a>处理任务</h3><p>切换当前终端窗口的目录到项目根目录下，执行</p><figure class="highlight bash"><table><tr><td class=gutter><pre><div class=line>1</div></pre></td><td class=code><pre><div class=line>php think queue:work --queue helloJobQueue</div></pre></td></tr></table></figure><p>可以看到执行的结果类似如下:</p><p><img src=/命令行执行结果.png alt=命令行执行结果></p><p>​</p><p>至此，我们成功地经历了一个消息的 创建 -&gt; 推送 -&gt; 消费 -&gt; 删除 的基本流程</p><p>下文，将介绍 thinkphp-queue 的详细使用方法。如配置介绍，基本原理，各种特殊情况的处理等</p><h2 id=二-详细介绍><a href=#二-详细介绍 class=headerlink title="二 详细介绍"></a>二 详细介绍</h2><h3 id=2-1-命令模式><a href=#2-1-命令模式 class=headerlink title="2.1 命令模式"></a>2.1 命令模式</h3><ul><li><p><strong>queue:subscribe 命令</strong> [截至2017-02-15，作者暂未实现该模式，略过]</p></li><li><p><strong>queue:work 命令</strong></p><p>work 命令： 该命令将启动一个 work 进程来处理消息队列。</p><figure class="highlight bash"><table><tr><td class=gutter><pre><div class=line>1</div></pre></td><td class=code><pre><div class=line>php think queue:work --queue helloJobQueue</div></pre></td></tr></table></figure></li><li><p><strong>queue:listen 命令</strong></p><p>listen 命令： 该命令将会创建一个 listen 父进程 ，然后由父进程通过 <code>proc_open(‘php think queue:work’)</code> 的方式来创建一个work 子 进程来处理消息队列，且限制该work进程的执行时间。</p><figure class="highlight bash"><table><tr><td class=gutter><pre><div class=line>1</div></pre></td><td class=code><pre><div class=line>php think queue:listen --queue helloJobQueue</div></pre></td></tr></table></figure></li></ul><h3 id=2-2-命令行参数><a href=#2-2-命令行参数 class=headerlink title="2.2 命令行参数"></a>2.2 命令行参数</h3><ul><li><p>Work 模式</p><figure class="highlight bash"><table><tr><td class=gutter><pre><div class=line>1</div><div class=line>2</div><div class=line>3</div><div class=line>4</div><div class=line>5</div><div class=line>6</div><div class=line>7</div><div class=line>8</div></pre></td><td class=code><pre><div class=line>php think queue:work \</div><div class=line>--daemon            //是否循环执行，如果不加该参数，则该命令处理完下一个消息就退出</div><div class=line>--queue  helloJobQueue  //要处理的队列的名称</div><div class=line>--delay  0 \        //如果本次任务执行抛出异常且任务未被删除时，设置其下次执行前延迟多少秒,默认为0</div><div class=line>--force  \          //系统处于维护状态时是否仍然处理任务，并未找到相关说明</div><div class=line>--memory 128 \      //该进程允许使用的内存上限，以 M 为单位</div><div class=line>--sleep  3 \        //如果队列中无任务，则sleep多少秒后重新检查(work+daemon模式)或者退出(listen或非daemon模式)</div><div class=line>--tries  2          //如果任务已经超过尝试次数上限，则触发‘任务尝试次数超限’事件，默认为0</div></pre></td></tr></table></figure></li><li><p>Listen 模式</p><figure class="highlight bash"><table><tr><td class=gutter><pre><div class=line>1</div><div class=line>2</div><div class=line>3</div><div class=line>4</div><div class=line>5</div><div class=line>6</div><div class=line>7</div></pre></td><td class=code><pre><div class=line>php think queue:listen \</div><div class=line>--queue  helloJobQueue \   //监听的队列的名称</div><div class=line>--delay  0 \         //如果本次任务执行抛出异常且任务未被删除时，设置其下次执行前延迟多少秒,默认为0</div><div class=line>--memory 128 \       //该进程允许使用的内存上限，以 M 为单位</div><div class=line>--sleep  3 \         //如果队列中无任务，则多长时间后重新检查，daemon模式下有效</div><div class=line>--tries  0 \         //如果任务已经超过重发次数上限，则进入失败处理逻辑，默认为0</div><div class=line>--timeout 60         //创建的work子进程的允许执行的最长时间，以秒为单位</div></pre></td></tr></table></figure><p>可以看到 listen 模式下，不包含 <code>--deamon</code> 参数，原因下面会说明</p></li></ul><h3 id=2-3-work-模式和-listen-模式的区别><a href=#2-3-work-模式和-listen-模式的区别 class=headerlink title="2.3 work 模式和 listen 模式的区别"></a>2.3 work 模式和 listen 模式的区别</h3><p>两者都可以用于处理消息队列中的任务</p><p>区别在于:</p><ul><li><p><strong>2.3.1 执行原理不同</strong></p><ul><li><p>work 命令是<strong>单进程</strong>的处理模式。</p><p>按照是否设置了 <code>--daemon</code> 参数，work命令又可分为单次执行和循环执行两种模式。</p><ul><li>单次执行：不添加 <code>--daemon</code>参数，该模式下,work进程在处理完下一个消息后直接结束当前进程。当不存在新消息时，会sleep一段时间然后退出。</li><li>循环执行：添加了 <code>--daemon</code>参数，该模式下,work进程会循环地处理队列中的消息，直到内存超出参数配置才结束进程。当不存在新消息时，会在每次循环中sleep一段时间。</li></ul></li><li><p>listen 命令是 <strong>父进程 + 子进程</strong> 的处理模式。</p><p>listen命令所在的父进程会创建一个<strong>单次执行模式的work子进程</strong>，并通过该work子进程来处理队列中的下一个消息，当这个work子进程退出之后，listen命令所在的父进程会监听到该子进程的退出信号，并重新创建一个新的<strong>单次执行的work子进程</strong></p></li></ul></li><li><p><strong>2.3.2 退出时机不同</strong></p><ul><li>work 命令的退出时机在上面的执行原理部分已叙述，此处不再重复</li><li><p>listen 命令中，listen所在的父进程正常情况会一直运行，除非遇到下面两种情况：</p><ul><li>创建的某个work子进程的执行时间超过了 listen命令行中的<code>--timeout</code> 参数配置，此时work子进程会被强制结束，listen所在的父进程也会抛出一个 <code>ProcessTimeoutException</code> 异常并退出。开发者可以选择捕获该异常，让父进程继续执行，也可以选择通过 supervisor 等监控软件重启一个新的listen命令。</li><li>listen 命令所在的父进程因某种原因存在内存泄露，则当父进程本身占用的内存超过了命令行中的 <code>--memory</code> 参数配置时，父子进程均会退出。正常情况下，listen进程本身占用的内存是稳定不变的。</li></ul></li></ul></li><li><p><strong>2.3.3 性能不同</strong></p><ul><li><p>work 命令是在脚本内部做循环，框架脚本在命令执行的初期就已加载完毕；</p></li><li><p>而listen模式则是处理完一个任务之后新开一个work进程，此时会重新加载框架脚本。</p><p>因此： <strong>work 模式的性能会比listen模式高</strong>。</p><p>注意：当代码有更新时，work 模式下需要手动去执行 <code>php think queue:restart</code> 命令重启队列来使改动生效；而listen 模式会自动生效,无需其他操作。</p></li></ul></li><li><p><strong>2.3.4 超时控制能力</strong></p><ul><li><p>work 模式本质上既不能控制进程自身的运行时间，也无法限制执行中的任务的执行时间。</p><p>举例来说，假如你在某次上线之后，在上文中的 <code>\application\index\job\Hello.php</code> 消费者的<code>fire</code>方法中添加了一段死循环 ：</p><figure class="highlight php"><table><tr><td class=gutter><pre><div class=line>1</div><div class=line>2</div><div class=line>3</div><div class=line>4</div><div class=line>5</div><div class=line>6</div></pre></td><td class=code><pre><div class=line><span class=keyword>public</span> <span class=function><span class=keyword>function</span> <span class=title>fire</span><span class=params>()</span></span>&#123;</div><div class=line>   <span class=keyword>while</span>(<span class=keyword>true</span>)&#123; <span class=comment>//死循环</span></div><div class=line>       $consoleOutPut-&gt;writeln(<span class=string>"&lt;info&gt;I am looping forever inside a job.&lt;/info&gt; \n"</span>);</div><div class=line>       sleep(<span class=number>1</span>);</div><div class=line>   &#125;</div><div class=line>&#125;</div></pre></td></tr></table></figure><p>那么这个循环将永远不能停止，直到任务所在的进程超过内存限制或者由管理员手动结束。这个过程不会有任何的告警。更严重的是，如果你配置了expire ，那么这个死循环的任务可能会污染到同样处理 <code>helloJobQueue</code> 队列的其他work进程，最后好几个work进程将被卡死在这段死循环中。详情后文会说明。</p><p><strong>work 模式下的超时控制能力，实际上应该理解为 多个work 进程配合下的过期任务重发能力。</strong></p></li><li><p>而 listen命令可以限制其创建的work子进程的超时时间。</p><p>listen 命令可通过 <code>--timeout</code> 参数限制work子进程允许运行的最长时间，超过该时间限制仍未结束的子进程会被强制结束；</p></li><li><p>这里有必要补充一下 expire 和 timeout 之间的区别：</p><ul><li>expire 在配置文件中设置，timeout 在 listen命令 的命令行参数中设置，而且，expire 和 timeout 是两个不同层次上的概念：</li></ul></li></ul></li></ul><figure class="highlight asciidoc"><table><tr><td class=gutter><pre><div class=line>1</div><div class=line>2</div></pre></td><td class=code><pre><div class=line><span class=bullet>- </span>expire 是指任务的过期时间。这个时间是全局的，影响到所有的work进程。(不管是独立的work命令还是 listen 模式下创建的的work子进程) 。expire 针对的对象是 *<span class=strong>*任务*</span><span class=strong>*。</span></div><div class=line><span class=strong>- timeout 是指work子进程的超时时间。这个时间只对当前执行的listen 命令有效。timeout 针对的对象是 *</span><span class=strong>*work子进程*</span><span class=strong>*。</span></div></pre></td></tr></table></figure><ul><li><p><strong>2.3.5 使用场景不同</strong></p><p>根据上面的介绍，可以看到，</p><p>work 命令的适用场景是：</p><ul><li>任务数量较多</li><li>性能要求较高</li><li>任务的执行时间较短</li><li>消费者类中不存在死循环，sleep() ，exit() ,die() 等容易导致bug的逻辑</li></ul><p>listen命令的适用场景是：</p><ul><li>任务数量较少</li><li>任务的执行时间较长(如生成大型的excel报表等)，</li><li>任务的执行时间需要有严格限制</li></ul></li></ul><h3 id=2-4-消息队列的开始，停止与重启><a href=#2-4-消息队列的开始，停止与重启 class=headerlink title="2.4 消息队列的开始，停止与重启"></a>2.4 消息队列的开始，停止与重启</h3><ul><li><p>开始一个消息队列：</p><figure class="highlight bash"><table><tr><td class=gutter><pre><div class=line>1</div></pre></td><td class=code><pre><div class=line>php think queue:work</div></pre></td></tr></table></figure></li><li><p>停止所有的消息队列：</p><figure class="highlight bash"><table><tr><td class=gutter><pre><div class=line>1</div></pre></td><td class=code><pre><div class=line>php think queue:restart</div></pre></td></tr></table></figure></li><li><p>重启所有的消息队列：</p><figure class="highlight bash"><table><tr><td class=gutter><pre><div class=line>1</div><div class=line>2</div></pre></td><td class=code><pre><div class=line>php think queue:restart</div><div class=line>php think queue:work</div></pre></td></tr></table></figure></li></ul><h3 id=2-5-多模块，多任务的处理><a href=#2-5-多模块，多任务的处理 class=headerlink title="2.5 多模块，多任务的处理"></a>2.5 多模块，多任务的处理</h3><ul><li><p>多模块</p><blockquote><p>单模块项目推荐使用 <code>app\job</code> 作为任务类的命名空间</p><p>多模块项目可用使用 <code>app\module\job</code> 作为任务类的命名空间 也可以放在任意可以自动加载到的地方</p></blockquote></li><li><p>多任务</p><blockquote><p>如果一个任务类里有多个小任务的话，在发布任务时，需要用 <code>任务的类名@方法名</code> 如 <code>app\lib\job\Job2@task1</code>、<code>app\lib\job\Job2@task2</code></p><p>注意：命令行中的 –queue 参数不支持@解析</p></blockquote><p>多任务例子:</p><ul><li>在 <code>\application\index\controller\JobTest.php</code> 控制器中，添加 <code>actionWithMultiTask()</code>方法：</li></ul><figure class="highlight php"><table><tr><td class=gutter><pre><div class=line>1</div><div class=line>2</div><div class=line>3</div><div class=line>4</div><div class=line>5</div><div class=line>6</div><div class=line>7</div><div class=line>8</div><div class=line>9</div><div class=line>10</div><div class=line>11</div><div class=line>12</div><div class=line>13</div><div class=line>14</div><div class=line>15</div><div class=line>16</div><div class=line>17</div><div class=line>18</div><div class=line>19</div><div class=line>20</div><div class=line>21</div><div class=line>22</div><div class=line>23</div><div class=line>24</div><div class=line>25</div></pre></td><td class=code><pre><div class=line><span class=keyword>public</span> <span class=function><span class=keyword>function</span> <span class=title>actionWithMultiTask</span><span class=params>()</span></span>&#123;</div><div class=line></div><div class=line>  $taskType = $_GET[<span class=string>'taskType'</span>];</div><div class=line>    <span class=keyword>switch</span> ($whichTask) &#123;</div><div class=line>       <span class=keyword>case</span> <span class=string>'taskA'</span>:</div><div class=line>           $jobHandlerClassName  = <span class=string>'application\index\job\MultiTask@taskA'</span>;</div><div class=line>           $jobDataArr = [<span class=string>'a'</span>    =&gt; <span class=string>'1'</span>];</div><div class=line>           $jobQueueName = <span class=string>"multiTaskJobQueue"</span>;</div><div class=line>           <span class=keyword>break</span>;</div><div class=line>       <span class=keyword>case</span> <span class=string>'taskB'</span>:</div><div class=line>           $jobHandlerClassName  = <span class=string>'application\index\job\MultiTask@taskB'</span>;</div><div class=line>           $jobDataArr = [<span class=string>'b'</span>    =&gt; <span class=string>'2'</span>];</div><div class=line>           $jobQueueName = <span class=string>"multiTaskJobQueue"</span>;        </div><div class=line>           <span class=keyword>break</span>;</div><div class=line>        <span class=keyword>default</span>:</div><div class=line>           <span class=keyword>break</span>;</div><div class=line>   &#125;</div><div class=line></div><div class=line>  $isPushed = Queue::push($jobHandlerClassName, $jobDataArr, $jobQueueName);</div><div class=line>  <span class=keyword>if</span> ($isPushed !== <span class=keyword>false</span>) &#123;</div><div class=line>    <span class=keyword>echo</span>(<span class=string>"the $taskType of MultiTask Job has been Pushed to "</span>.$jobQueueName .<span class=string>"&lt;br&gt;"</span>);</div><div class=line>  &#125;<span class=keyword>else</span>&#123;</div><div class=line>    <span class=keyword>throw</span> <span class=keyword>new</span> <span class=keyword>Exception</span>(<span class=string>"push a new $taskType of MultiTask Job Failed!"</span>);</div><div class=line>  &#125;</div><div class=line>&#125;</div></pre></td></tr></table></figure><ul><li>新增 <code>\application\index\job\MultiTask.php</code> 消费者类，并编写其 <code>taskA()</code> 和 <code>taskB()</code>方法</li></ul><figure class="highlight php"><table><tr><td class=gutter><pre><div class=line>1</div><div class=line>2</div><div class=line>3</div><div class=line>4</div><div class=line>5</div><div class=line>6</div><div class=line>7</div><div class=line>8</div><div class=line>9</div><div class=line>10</div><div class=line>11</div><div class=line>12</div><div class=line>13</div><div class=line>14</div><div class=line>15</div><div class=line>16</div><div class=line>17</div><div class=line>18</div><div class=line>19</div><div class=line>20</div><div class=line>21</div><div class=line>22</div><div class=line>23</div><div class=line>24</div><div class=line>25</div><div class=line>26</div><div class=line>27</div><div class=line>28</div><div class=line>29</div><div class=line>30</div><div class=line>31</div><div class=line>32</div><div class=line>33</div><div class=line>34</div><div class=line>35</div><div class=line>36</div><div class=line>37</div><div class=line>38</div><div class=line>39</div><div class=line>40</div><div class=line>41</div><div class=line>42</div><div class=line>43</div><div class=line>44</div><div class=line>45</div><div class=line>46</div><div class=line>47</div><div class=line>48</div></pre></td><td class=code><pre><div class=line><span class=meta>&lt;?php</span></div><div class=line><span class=comment>/**</span></div><div class=line><span class=comment> * 文件路径： \application\index\job\MultiTask.php</span></div><div class=line><span class=comment> * 这是一个消费者类，用于处理 multiTaskJobQueue 队列中的任务</span></div><div class=line><span class=comment> */</span></div><div class=line><span class=keyword>namespace</span> <span class=title>application</span>\<span class=title>index</span>\<span class=title>job</span>;</div><div class=line></div><div class=line><span class=keyword>use</span> <span class=title>think</span>\<span class=title>queue</span>\<span class=title>Job</span>;</div><div class=line></div><div class=line><span class=class><span class=keyword>class</span> <span class=title>MultiTask</span> </span>&#123;</div><div class=line></div><div class=line>    <span class=keyword>public</span> <span class=function><span class=keyword>function</span> <span class=title>taskA</span><span class=params>(Job $job,$data)</span></span>&#123;</div><div class=line></div><div class=line>        $isJobDone = <span class=keyword>$this</span>-&gt;_doTaskA($data);</div><div class=line></div><div class=line>        <span class=keyword>if</span> ($isJobDone) &#123;</div><div class=line>            $job-&gt;delete();</div><div class=line>            <span class=keyword>print</span>(<span class=string>"Info: TaskA of Job MultiTask has been done and deleted"</span>.<span class=string>"\n"</span>);</div><div class=line>        &#125;<span class=keyword>else</span>&#123;</div><div class=line>            <span class=keyword>if</span> ($job-&gt;attempts() &gt; <span class=number>3</span>) &#123;</div><div class=line>                $job-&gt;delete();     </div><div class=line>            &#125;</div><div class=line>        &#125;</div><div class=line>    &#125;</div><div class=line></div><div class=line>    <span class=keyword>public</span> <span class=function><span class=keyword>function</span> <span class=title>taskB</span><span class=params>(Job $job,$data)</span></span>&#123;</div><div class=line></div><div class=line>        $isJobDone = <span class=keyword>$this</span>-&gt;_doTaskA($data);</div><div class=line></div><div class=line>        <span class=keyword>if</span> ($isJobDone) &#123;</div><div class=line>            $job-&gt;delete();</div><div class=line>            <span class=keyword>print</span>(<span class=string>"Info: TaskB of Job MultiTask has been done and deleted"</span>.<span class=string>"\n"</span>);</div><div class=line>        &#125;<span class=keyword>else</span>&#123;</div><div class=line>            <span class=keyword>if</span> ($job-&gt;attempts() &gt; <span class=number>2</span>) &#123;</div><div class=line>                $job-&gt;release();     </div><div class=line>            &#125;</div><div class=line>        &#125;</div><div class=line>    &#125;</div><div class=line></div><div class=line>    <span class=keyword>private</span> <span class=function><span class=keyword>function</span> <span class=title>_doTaskA</span><span class=params>($data)</span> </span>&#123;</div><div class=line>        <span class=keyword>print</span>(<span class=string>"Info: doing TaskA of Job MultiTask "</span>.<span class=string>"\n"</span>);</div><div class=line>        <span class=keyword>return</span> <span class=keyword>true</span>;</div><div class=line>    &#125;</div><div class=line></div><div class=line>    <span class=keyword>private</span> <span class=function><span class=keyword>function</span> <span class=title>_doTaskB</span><span class=params>($data)</span> </span>&#123;</div><div class=line>        <span class=keyword>print</span>(<span class=string>"Info: doing TaskB of Job MultiTask "</span>.<span class=string>"\n"</span>);</div><div class=line>        <span class=keyword>return</span> <span class=keyword>true</span>;</div><div class=line>    &#125;</div></pre></td></tr></table></figure></li></ul><h3 id=2-6-消息的延迟执行与定时执行><a href=#2-6-消息的延迟执行与定时执行 class=headerlink title="2.6 消息的延迟执行与定时执行"></a>2.6 消息的延迟执行与定时执行</h3><p>延迟执行，相对于即时执行，是用来限制某个任务的最早可执行时刻。在到达该时刻之前，该任务会被跳过。</p><p>可以利用该功能实现<strong>定时任务</strong>。</p><p>使用方式：</p><ul><li>在生产者业务代码中：</li></ul><figure class="highlight php"><table><tr><td class=gutter><pre><div class=line>1</div><div class=line>2</div><div class=line>3</div><div class=line>4</div><div class=line>5</div><div class=line>6</div><div class=line>7</div></pre></td><td class=code><pre><div class=line><span class=comment>// 即时执行</span></div><div class=line>$isPushed = Queue::push($jobHandlerClassName, $jobDataArr, $jobQueueName);</div><div class=line><span class=comment>// 延迟 2 秒执行</span></div><div class=line>$isPushed = Queue::later( <span class=number>2</span>, $jobHandlerClassName, $jobDataArr, $jobQueueName);</div><div class=line><span class=comment>// 延迟到 2017-02-18 01:01:01 时刻执行</span></div><div class=line>$time2wait = strtotime(<span class=string>'2017-02-18 01:01:01'</span>) - strtotime(<span class=string>'now'</span>);</div><div class=line>$isPushed = Queue::later($time2wait,$jobHandlerClassName, $jobDataArr, $jobQueueName);</div></pre></td></tr></table></figure><ul><li>在消费者类中：</li></ul><figure class="highlight php"><table><tr><td class=gutter><pre><div class=line>1</div><div class=line>2</div><div class=line>3</div><div class=line>4</div><div class=line>5</div><div class=line>6</div><div class=line>7</div></pre></td><td class=code><pre><div class=line><span class=comment>// 重发，即时执行</span></div><div class=line>$job-&gt;release();</div><div class=line><span class=comment>// 重发，延迟 2 秒执行</span></div><div class=line>$job-&gt;release(<span class=number>2</span>);</div><div class=line><span class=comment>// 延迟到 2017-02-18 01:01:01 时刻执行</span></div><div class=line>$time2wait = strtotime(<span class=string>'2017-02-18 01:01:01'</span>) - strtotime(<span class=string>'now'</span>);</div><div class=line>$job-&gt;release($time2wait);</div></pre></td></tr></table></figure><ul><li>在命令行中：</li></ul><figure class="highlight bash"><table><tr><td class=gutter><pre><div class=line>1</div><div class=line>2</div></pre></td><td class=code><pre><div class=line>//如果消费者类的fire()方法抛出了异常且任务未被删除时，将自动重发该任务，重发时，会设置其下次执行前延迟多少秒,默认为0</div><div class=line>php think queue:work --delay 3</div></pre></td></tr></table></figure><h3 id=2-7-消息的重发><a href=#2-7-消息的重发 class=headerlink title="2.7 消息的重发"></a>2.7 消息的重发</h3><p>thinkphp-queue 中，消息的重发时机有3种：</p><ul><li>2.7.1 在消费者类中手动重发：</li></ul><figure class="highlight php"><table><tr><td class=gutter><pre><div class=line>1</div><div class=line>2</div><div class=line>3</div></pre></td><td class=code><pre><div class=line><span class=keyword>if</span>( $isJobDone === <span class=keyword>false</span>)&#123;</div><div class=line>    $job-&gt;release();</div><div class=line>&#125;</div></pre></td></tr></table></figure><ul><li><p>2.7.2 work进程自动重发，需同时满足以下两个条件</p><ul><li>消费者类的 fire() 方法抛出了异常</li><li>任务未被删除</li></ul></li><li><p>2.7.3 当配置了 expire 不为 <code>null</code> 时，work 进程内部每次查询可用任务之前，会先自动重发已过期的任务。</p></li></ul><blockquote><p>补充：</p><p>在database 模式下，2.7.1 和 2.7.2 中的重发逻辑是先删除原来的任务，然后插入一个新的任务。2.7.3 中的重发时机是直接更新原任务。</p><p>而在redis 模式下，3种重发都是先删除再插入。</p><p>不管是哪种重发方式，重发之后，任务的已尝试次数会在原来的基础上 +1 。</p></blockquote><p>此外，消费者类中需要注意，如果 <code>fire()</code> 方法中可能抛出异常，那么</p><ul><li>如果不需要自动重发的话， 请在抛出异常之前将任务删除 <code>$job-&gt;delete()</code> ，以免产生bug。</li><li>如果需要自动重发的话，请直接抛出异常，不要在 <code>fire()</code> 方法中又手动使用 <code>$job-&gt;release()</code> , 这样会导致该任务被重发两次，产生两个一样的新任务。</li></ul><h3 id=2-8-任务的失败回调及告警><a href=#2-8-任务的失败回调及告警 class=headerlink title="2.8 任务的失败回调及告警"></a>2.8 任务的失败回调及告警</h3><p>当同时满足以下条件时，将触发任务失败回调：</p><ul><li>命令行的 <code>--tries</code> 参数的值大于0</li><li>任务的已尝试次数大于 命令行的 <code>--tries</code> 参数</li><li>开发者添加了 <code>queue_failed</code> 事件标签及其对应的回调代码</li><li>消费者类中定义了 <code>failed()</code> 方法，用于接收任务失败的通知</li></ul><p>注意， <code>queue_failed</code> 标签需要在安装了 <code>thinkphp-queue</code> 之后 <strong>手动</strong> 去 <code>\application\tags.php</code> 文件中添加。</p><p><strong>注意：该版本有<a href=https://github.com/top-think/think-queue/issues/10 target=_blank rel=external>bug</a>，若想实现失败任务回调功能，需要先修改位于 <code>think-queue\src\queue\Worker.php</code> 中的 <code>logFailedJob</code>方法 , 修改方式如下:</strong></p><figure class="highlight php"><table><tr><td class=gutter><pre><div class=line>1</div><div class=line>2</div><div class=line>3</div><div class=line>4</div><div class=line>5</div><div class=line>6</div><div class=line>7</div><div class=line>8</div><div class=line>9</div><div class=line>10</div><div class=line>11</div><div class=line>12</div><div class=line>13</div><div class=line>14</div><div class=line>15</div></pre></td><td class=code><pre><div class=line><span class=comment>/**</span></div><div class=line><span class=comment> * Log a failed job into storage.</span></div><div class=line><span class=comment> * <span class=doctag>@param</span>  \Think\Queue\Job $job</span></div><div class=line><span class=comment> * <span class=doctag>@return</span> array</span></div><div class=line><span class=comment> */</span></div><div class=line>    <span class=keyword>protected</span> <span class=function><span class=keyword>function</span> <span class=title>logFailedJob</span><span class=params>(Job $job)</span></span></div><div class=line><span class=function>    </span>&#123;</div><div class=line>        <span class=comment>// 将原来的 queue.failed' 修改为 'queue_failed' 才可以触发任务失败回调</span></div><div class=line>        <span class=keyword>if</span> (Hook::listen(<span class=string>'queue.failed'</span>, $job, <span class=keyword>null</span>, <span class=keyword>true</span>)) &#123;  </div><div class=line>            $job-&gt;delete();</div><div class=line>            $job-&gt;failed();</div><div class=line>        &#125;</div><div class=line></div><div class=line>        <span class=keyword>return</span> [<span class=string>'job'</span> =&gt; $job, <span class=string>'failed'</span> =&gt; <span class=keyword>true</span>];</div><div class=line>    &#125;</div></pre></td></tr></table></figure><p>首先，我们添加 <code>queue_failed</code> 事件标签, 及其对应的回调方法</p><figure class="highlight php"><table><tr><td class=gutter><pre><div class=line>1</div><div class=line>2</div><div class=line>3</div><div class=line>4</div><div class=line>5</div><div class=line>6</div><div class=line>7</div><div class=line>8</div><div class=line>9</div><div class=line>10</div><div class=line>11</div><div class=line>12</div><div class=line>13</div><div class=line>14</div><div class=line>15</div><div class=line>16</div><div class=line>17</div><div class=line>18</div><div class=line>19</div><div class=line>20</div><div class=line>21</div><div class=line>22</div><div class=line>23</div><div class=line>24</div><div class=line>25</div><div class=line>26</div><div class=line>27</div><div class=line>28</div><div class=line>29</div><div class=line>30</div><div class=line>31</div><div class=line>32</div><div class=line>33</div><div class=line>34</div><div class=line>35</div><div class=line>36</div><div class=line>37</div><div class=line>38</div><div class=line>39</div></pre></td><td class=code><pre><div class=line><span class=comment>// 文件路径： \application\tags.php</span></div><div class=line><span class=comment>// 应用行为扩展定义文件</span></div><div class=line><span class=keyword>return</span> [</div><div class=line>    <span class=comment>// 应用初始化</span></div><div class=line>    <span class=string>'app_init'</span>     =&gt; [],</div><div class=line>    <span class=comment>// 应用开始</span></div><div class=line>    <span class=string>'app_begin'</span>    =&gt; [],</div><div class=line>    <span class=comment>// 模块初始化</span></div><div class=line>    <span class=string>'module_init'</span>  =&gt; [],</div><div class=line>    <span class=comment>// 操作开始执行</span></div><div class=line>    <span class=string>'action_begin'</span> =&gt; [],</div><div class=line>    <span class=comment>// 视图内容过滤</span></div><div class=line>    <span class=string>'view_filter'</span>  =&gt; [],</div><div class=line>    <span class=comment>// 日志写入</span></div><div class=line>    <span class=string>'log_write'</span>    =&gt; [],</div><div class=line>    <span class=comment>// 应用结束</span></div><div class=line>    <span class=string>'app_end'</span>      =&gt; [],</div><div class=line></div><div class=line>    <span class=comment>// 任务失败统一回调,有四种定义方式</span></div><div class=line>    <span class=string>'queue_failed'</span>=&gt; [</div><div class=line></div><div class=line>         <span class=comment>// 数组形式，[ 'ClassName' , 'methodName']</span></div><div class=line>        [<span class=string>'application\\behavior\\MyQueueFailedLogger'</span>, <span class=string>'logAllFailedQueues'</span>]</div><div class=line></div><div class=line>         <span class=comment>// 字符串(静态方法)，'StaicClassName::methodName'</span></div><div class=line>         <span class=comment>// 'MyQueueFailedLogger::logAllFailedQueues'   </span></div><div class=line></div><div class=line>         <span class=comment>// 字符串(对象方法)，'ClassName'，此时需在对应的ClassName类中添加一个名为 queueFailed 的方法</span></div><div class=line>         <span class=comment>// 'application\\behavior\\MyQueueFailedLogger'</span></div><div class=line></div><div class=line>         <span class=comment>// 闭包形式</span></div><div class=line>         <span class=comment>/*</span></div><div class=line><span class=comment>         function( &amp;$jobObject , $extra)&#123;</span></div><div class=line><span class=comment>             // var_dump($jobObject);</span></div><div class=line><span class=comment>             return true;</span></div><div class=line><span class=comment>         &#125;</span></div><div class=line><span class=comment>         */</span></div><div class=line>    ]</div><div class=line>];</div></pre></td></tr></table></figure><p>这里，我们选择数组形式的回调方式，新增 <code>\application\behavior\MyQueueFailedLogger</code> 类，添加一个 <code>logAllFailedQueues()</code> 方法</p><figure class="highlight php"><table><tr><td class=gutter><pre><div class=line>1</div><div class=line>2</div><div class=line>3</div><div class=line>4</div><div class=line>5</div><div class=line>6</div><div class=line>7</div><div class=line>8</div><div class=line>9</div><div class=line>10</div><div class=line>11</div><div class=line>12</div><div class=line>13</div><div class=line>14</div><div class=line>15</div><div class=line>16</div><div class=line>17</div><div class=line>18</div><div class=line>19</div><div class=line>20</div><div class=line>21</div><div class=line>22</div><div class=line>23</div><div class=line>24</div><div class=line>25</div><div class=line>26</div><div class=line>27</div><div class=line>28</div><div class=line>29</div><div class=line>30</div><div class=line>31</div><div class=line>32</div><div class=line>33</div><div class=line>34</div></pre></td><td class=code><pre><div class=line><span class=meta>&lt;?php</span></div><div class=line><span class=comment>/**</span></div><div class=line><span class=comment> * 文件路径: \application\behavior\MyQueueFailedLogger.php</span></div><div class=line><span class=comment> * 这是一个行为类，用于处理所有的消息队列中的任务失败回调</span></div><div class=line><span class=comment> */</span></div><div class=line></div><div class=line><span class=keyword>namespace</span> <span class=title>application</span>\<span class=title>behavior</span>;</div><div class=line></div><div class=line></div><div class=line><span class=class><span class=keyword>class</span> <span class=title>MyQueueFailedLogger</span> </span>&#123;</div><div class=line></div><div class=line>    <span class=keyword>const</span> should_run_hook_callback = <span class=keyword>true</span>;</div><div class=line></div><div class=line>    <span class=comment>/**</span></div><div class=line><span class=comment>     * <span class=doctag>@param</span> $jobObject   \think\queue\Job   //任务对象，保存了该任务的执行情况和业务数据</span></div><div class=line><span class=comment>     * <span class=doctag>@return</span> bool     true                  //是否需要删除任务并触发其failed() 方法</span></div><div class=line><span class=comment>     */</span></div><div class=line>    <span class=keyword>public</span> <span class=function><span class=keyword>function</span> <span class=title>logAllFailedQueues</span><span class=params>(&amp;$jobObject)</span></span>&#123;</div><div class=line></div><div class=line>        $failedJobLog = [</div><div class=line>            <span class=string>'jobHandlerClassName'</span>   =&gt; $jobObject-&gt;getName(), <span class=comment>// 'application\index\job\Hello'</span></div><div class=line>            <span class=string>'queueName'</span> =&gt; $jobObject-&gt;getQueue(),               <span class=comment>// 'helloJobQueue'     </span></div><div class=line>            <span class=string>'jobData'</span>   =&gt; $jobObject-&gt;getRawBody()[<span class=string>'data'</span>],  <span class=comment>// '&#123;'a': 1 &#125;'</span></div><div class=line>            <span class=string>'attempts'</span>  =&gt; $jobObject-&gt;attempts(),            <span class=comment>// 3</span></div><div class=line>        ];</div><div class=line>        var_export(json_encode($failedJobLog,<span class=keyword>true</span>));</div><div class=line></div><div class=line>           <span class=comment>// $jobObject-&gt;release();     //重发任务</span></div><div class=line>          <span class=comment>//$jobObject-&gt;delete();         //删除任务</span></div><div class=line>          <span class=comment>//$jobObject-&gt;failed();      //通知消费者类任务执行失败</span></div><div class=line></div><div class=line>        <span class=keyword>return</span> <span class=keyword>self</span>::should_run_hook_callback;         </div><div class=line>    &#125;</div><div class=line>&#125;</div></pre></td></tr></table></figure><p>需要注意该回调方法的返回值：</p><ul><li>返回 true 时，系统会自动删除该任务，并且自动调用消费者类中的 <code>failed()</code> 方法</li><li>返回 false 时，系统不会自动删除该任务，也不会自动调用消费者类中的 <code>failed()</code> 方法，需要开发者另行处理失败任务的删除和通知。</li></ul><p>最后，在消费者类中，添加 <code>failed()</code> 方法</p><figure class="highlight php"><table><tr><td class=gutter><pre><div class=line>1</div><div class=line>2</div><div class=line>3</div><div class=line>4</div><div class=line>5</div><div class=line>6</div><div class=line>7</div><div class=line>8</div><div class=line>9</div><div class=line>10</div><div class=line>11</div><div class=line>12</div><div class=line>13</div></pre></td><td class=code><pre><div class=line><span class=comment>/**</span></div><div class=line><span class=comment> * 文件路径： \application\index\job\HelloJob.php</span></div><div class=line><span class=comment> */</span></div><div class=line></div><div class=line><span class=comment>/**</span></div><div class=line><span class=comment> * 该方法用于接收任务执行失败的通知，你可以发送邮件给相应的负责人员</span></div><div class=line><span class=comment> * <span class=doctag>@param</span> $jobData  string|array|...      //发布任务时传递的 jobData 数据</span></div><div class=line><span class=comment> */</span></div><div class=line><span class=keyword>public</span> <span class=function><span class=keyword>function</span> <span class=title>failed</span><span class=params>($jobData)</span></span>&#123;</div><div class=line>    send_mail_to_somebody() ;</div><div class=line></div><div class=line>    <span class=keyword>print</span>(<span class=string>"Warning: Job failed after max retries. job data is :"</span>.var_export($data,<span class=keyword>true</span>).<span class=string>"\n"</span>;</div><div class=line>&#125;</div></pre></td></tr></table></figure><p>这样，就可以做到任务失败的<strong>记录</strong>与<strong>告警</strong></p><h3 id=2-9-处理过期的任务><a href=#2-9-处理过期的任务 class=headerlink title="2.9 处理过期的任务"></a>2.9 处理过期的任务</h3><p>过期这个概念用文字比较难描述清楚，建议先看一下 <strong>深入理解</strong> 中 <strong>3.4 消息处理的详细流程图</strong></p><h2 id=三-深入理解><a href=#三-深入理解 class=headerlink title="三 深入理解"></a>三 深入理解</h2><h3 id=3-1-thinkphp-queue-中消息与队列的保存方式><a href=#3-1-thinkphp-queue-中消息与队列的保存方式 class=headerlink title="3.1 thinkphp-queue 中消息与队列的保存方式"></a>3.1 thinkphp-queue 中消息与队列的保存方式</h3><ul><li><p>Redis</p><p>在 Redis 中，每一个 队列 都三个key 与之对应 ，以 helloJobQueue 队列举例，其在redis 中的保存方式为：</p><p>| key名 | 类型 | 说明 | | —————————– | ————— | ————– | | queues:helloJobQueue | List ， 列表 | 待执行的任务列表 | | queues:helloJobQueue:delayed | Sorted Set，有序集合 | 延迟执行和定时执行的任务集合 | | queues:helloJobQueue:reserved | Sorted Set，有序集合 | 执行中的任务集合 |</p><blockquote><p>使用的<code>:</code>分隔符, 只是用来表示相关key的关联性。本身没有特殊含义。使用分隔符是一种常见的组织key的方式。</p></blockquote><p>其中，在<code>queues:helloJobQueue</code> 列表中，每个元素的形式如下：</p><p><img src=/redis中的队列-queue.png alt=redis中的队列-queue></p><p>在 <code>queues:helloJobQueue:delayed</code> 和 <code>queues:helloJobQueue:delayed</code> 有序集合中，每个元素的形式如下：</p><p><img src=/redis中的队列-queue-reserved.png alt=redis中的队列-queue-reserved></p><p>可以看到，在有序集合中，每个元素代表一个任务，该元素的 Score 为该任务的入队时间戳，任务的 value 为json 格式，保存了任务的执行情况和业务数据。将value decode 为数组后形式如下：</p><figure class="highlight php"><table><tr><td class=gutter><pre><div class=line>1</div><div class=line>2</div><div class=line>3</div><div class=line>4</div><div class=line>5</div><div class=line>6</div><div class=line>7</div><div class=line>8</div><div class=line>9</div></pre></td><td class=code><pre><div class=line>[</div><div class=line>  <span class=string>'job'</span>  =&gt; <span class=string>'application\\index\\job\\Hello'</span> ,  <span class=comment>// jobHandlerClassName，消费者类的类名</span></div><div class=line>  <span class=string>'data'</span> =&gt; [                      <span class=comment>// 生产者传入的业务数据</span></div><div class=line>     <span class=string>'time'</span> =&gt; <span class=string>'2017-02-18 16:20:10'</span>,</div><div class=line>     <span class=string>'data'</span> =&gt; <span class=string>'I have 648 apples'</span></div><div class=line>  ],</div><div class=line>  <span class=string>'id'</span>   =&gt; <span class=string>'77IasdasadIasdadadadKL8t'</span>,    <span class=comment>// 一个随机的32位字符串</span></div><div class=line>  <span class=string>'attempts'</span> =&gt; <span class=number>2</span>                <span class=comment>// 任务的已尝试次数</span></div><div class=line>]</div></pre></td></tr></table></figure><p>redis驱动下，为了实现任务的延迟执行和过期重发，任务将在这三个key中来回转移，详情可见 3.5</p></li><li><p>Database</p><p>在 Database 中，每个任务对应到表中的一行，queue 字段用来区分不同的队列。</p><p>表的字段结构如下:</p><p><img src=/数据库字段说明.png alt=数据库字段说明></p><p>其中，payLoad 字段保存了消息的执行者和业务数据，payLoad 字段采用 json 格式的字符串来保存消息，将其 decode 为数组后形式如下：</p><figure class="highlight php"><table><tr><td class=gutter><pre><div class=line>1</div><div class=line>2</div><div class=line>3</div><div class=line>4</div></pre></td><td class=code><pre><div class=line>[</div><div class=line> <span class=string>'job'</span>   =&gt; <span class=string>'application\\index\\job\\Hello'</span>, <span class=comment>// jobHandlerClassName，消费者类的类名</span></div><div class=line> <span class=string>'data'</span>  =&gt; string|<span class=keyword>array</span>|integer|object       <span class=comment>// 生产者传入的业务数据</span></div><div class=line>]</div></pre></td></tr></table></figure></li></ul><h3 id=3-2-thinkphp-queue-的目录结构和类关系图><a href=#3-2-thinkphp-queue-的目录结构和类关系图 class=headerlink title="3.2 thinkphp-queue 的目录结构和类关系图"></a>3.2 thinkphp-queue 的目录结构和类关系图</h3><p><img src=/thinkphp-queue的文件目录.png alt=thinkphp-queue的文件目录></p><p>这些类构成了消息队列中的几个角色：</p><table><thead><tr><th>角色</th><th>类名</th><th>说明</th></tr></thead><tbody><tr><td>命令行</td><td>Command + Worker</td><td>负责解析命令行参数，控制队列的启动，重启</td></tr><tr><td>驱动</td><td>Queue + Connector</td><td>负责队列的创建，以及消息的入队，出队等操作</td></tr><tr><td>任务</td><td>Job</td><td>用于将消息转化为一个任务对象，供消费者使用</td></tr><tr><td>生产者</td><td>业务代码</td><td>负责消息的创建与发布</td></tr><tr><td>消费者</td><td>业务代码</td><td>负责任务的接收与执行</td></tr></tbody></table><p>各个类之间的关系图如下：</p><p><img src=https://blog.huzhongyuan.com/wp-content/uploads/2017/02/thinkphp-queue%E7%B1%BB%E5%85%B3%E7%B3%BB%E5%9B%BE.svg alt=thinkphp-queue类关系图></p><h3 id=3-3-Deamon模式的执行流程><a href=#3-3-Deamon模式的执行流程 class=headerlink title="3.3 Deamon模式的执行流程"></a>3.3 Deamon模式的执行流程</h3><p><img src=https://blog.huzhongyuan.com/wp-content/uploads/2017/02/Daemon%E6%A8%A1%E5%BC%8F%E4%B8%8E%E9%9D%9Edaemon%E6%A8%A1%E5%BC%8F%E7%8A%B6%E6%80%81%E5%9B%BE.svg alt=Daemon模式与非daemon模式状态图></p><h3 id=3-4-Database模式下消息处理的详细流程><a href=#3-4-Database模式下消息处理的详细流程 class=headerlink title="3.4 Database模式下消息处理的详细流程"></a>3.4 Database模式下消息处理的详细流程</h3><p>下图中，展示了database 模式下消息处理的详细流程，redis 驱动下大体类似</p><p><img src=https://blog.huzhongyuan.com/wp-content/uploads/2017/02/Database%E9%A9%B1%E5%8A%A8%E4%B8%8B%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86%E7%9A%84%E5%85%B7%E4%BD%93%E6%B5%81%E7%A8%8B.svg alt=Database模式下消息获取和执行的具体流程></p><h3 id=3-5-redis-驱动下的任务重发细节><a href=#3-5-redis-驱动下的任务重发细节 class=headerlink title="3.5 redis 驱动下的任务重发细节"></a>3.5 redis 驱动下的任务重发细节</h3><p>在redis驱动下，为了实现任务的延迟执行和过期重发，任务将在这三个key中来回转移。</p><p>在3.4 Database模式下消息处理的消息流程中，我们知道，如果配置的expire 不是null ，那么 thinkphp-queue的work进程每次在获取下一个可执行任务之前，会先尝试重发所有过期的任务。而在redis驱动下，这个步骤则做了更多的事情，详情如下：</p><ol><li>从 <code>queue:xxx:delayed</code> 的key中查询出有哪些任务在当前时刻已经可以开始执行，然后将这些任务转移到 <code>queue:xxx</code> 的key的尾部。</li><li>从 <code>queue:xxx:reserved</code> 的key中查询出有哪些任务在当前时刻已经过期，然后将这些任务转移到 <code>queue:xxx</code>的key的尾部。</li><li>尝试从 <code>queue:xxx</code> 的key的头部取出一个任务，如果取出成功，那么，将这个任务转移到 <code>queue:xxx:reserved</code> 的key 的头部，同时将这个任务实例化成任务对象，交给消费者去执行。</li></ol><p>用图来表示这个步骤的具体过程如下：</p><p>redis队列中的过期任务重发步骤–执行前：</p><p><img src=https://blog.huzhongyuan.com/wp-content/uploads/2017/02/redis%E9%98%9F%E5%88%97%E4%B8%AD%E7%9A%84%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86-1.png alt=redis队列中的过期任务重发步骤-执行前></p><p>redis队列中的过期任务重发步骤–执行后：</p><p><img src=https://blog.huzhongyuan.com/wp-content/uploads/2017/02/redis%E9%98%9F%E5%88%97%E4%B8%AD%E7%9A%84%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86-2.png alt=redis队列中的过期任务重发步骤--执行后></p><h3 id=3-6-thinkphp-queue的性能><a href=#3-6-thinkphp-queue的性能 class=headerlink title="3.6 thinkphp-queue的性能"></a>3.6 thinkphp-queue的性能</h3><ul><li><p>测试环境 :</p><p>虚拟机 Ubuntu 16.04 ， PHP 7.1 ，TP5，Redis 3.2 ， 双核 I5 6400，3G 内存</p></li><li><p>测试方式 :</p><p>使用 Redis 驱动，在一个控制器中循环推送 40000 条消息到消息队列；</p><p>使用<code>php think queue:work --daemon</code>去消费这些消息，计算推送和消费各自所耗的时间。</p></li><li><p>测试结果 :</p><p>在最简单的逻辑下，平均每秒中可推送8000个消息，平均每秒可消费200个消息。</p></li></ul><p><strong>注意：</strong>由于在测试时，Host 机本身的cpu和内存长期100%，并且虚拟机中的各项服务并未专门调优，因此该测试结果<strong>并不具备参考性</strong>。</p><h3 id=3-7-thinkphp-queue-的N种错误使用姿势><a href=#3-7-thinkphp-queue-的N种错误使用姿势 class=headerlink title="3.7 thinkphp-queue 的N种错误使用姿势"></a>3.7 thinkphp-queue 的N种错误使用姿势</h3><ul><li><p><strong>3.7.1</strong> 在 消费者类的 <code>fire()</code> 方法中，忘记使用 <code>$job-&gt;delete()</code> 去删除消息，这种情况下，会产生一系列的bug：</p><ul><li><p>配置的 expire 为 <code>null</code> ， 则该任务被执行一次后会永远留在消息队列中，占用消息队列的空间 , 除非开发者另行处理。</p></li><li><p>配置的 expire <code>不为 null</code> ，该任务在 expire 秒后被认为是过期任务，并被消息队列还原为待执行状态，在消息队列的后面的循环中继续被获取，这时，如果</p><ul><li>命令行中的 <code>--tries</code> 参数为0 或者未设置,那么每隔 一段时间该任务就会被执行一次。</li><li><p>命令行中的 <code>--tries</code> 参数 n 大于0 ， 那么当这个任务被误执行的次数超过n 时，会由消息队列尝试去触发失败回调事件:</p><ul><li>如果开发者没有编写失败处理的回调事件：那么该任务仍然不会被删除，每隔一段时间就会被执行一次。[这个可能属于框架的<a href=https://github.com/top-think/think-queue/issues/10 target=_blank rel=external>Bug</a>] ,</li><li><p>如果编写了失败回调事件</p><ul><li>回调事件中删除了任务，则这个任务被误执行了 n 次。</li><li><p>回调事件中未删除任务，这时，如果：</p><ul><li>回调事件返回值是 false，那么该任务仍然不会被删除，每隔一段时间就会被执行一次</li><li>回调事件返回值是 true， 那么该任务会先被删除，然后触发消费者类的 failed() 方法，如果在 failed() 方法中设置了告警，那么这个告警就是一次误报。</li></ul></li></ul></li></ul></li></ul></li></ul><p>因此，在 使用 thinkphp-queue 时，请记得：</p><ul><li><strong>任务完成后, 使用 <code>$job-&gt;delete()</code> 删除任务</strong></li><li>在消费者类的 <code>fire()</code> 方法中，使用 <code>$job-&gt;attempt()</code> 检查任务已执行次数，对于次数异常的，作相应的处理。</li><li>在消费者类的 <code>fire()</code> 方法中，根据业务数据来判断该任务是否已经执行过，以避免该任务被重复执行。</li><li>编写失败回调事件，将事件中失败的任务及时通知给开发人员。</li></ul></li><li><p><strong>3.7.2</strong> 使用了 <code>queue:work --daemon</code> ，但更新代码后没有使用 <code>queue:restart</code> 重启 work 进程, 使得 work 进程中的代码与最新的代码不同，出现各种问题。</p></li><li><p><strong>3.7.3</strong> 使用了 <code>queue:work --daemon</code> ，但是消费者类的 fire() 方法中存在死循环，或 <code>sleep(n)</code> 等逻辑，导致消息队列被堵塞；或者使用了 <code>exit()</code> , <code>die()</code> 这样的逻辑，导致work进程直接终止 。</p></li><li><p><strong>3.7.4</strong> 配置的 expire 为 <code>null</code> ，这时如果采用的是 Redis 驱动且使用了延迟功能，如 <code>later(n)</code> ， <code>release(n)</code> 方法或者 <code>--delay</code> 参数不为0 ， 那么将导致被延迟的任务永远无法处理。(这个可能属于框架的<a href=https://github.com/top-think/think-queue/issues/12 target=_blank rel=external>Bug</a>)</p></li><li><p><strong>3.7.5</strong> 配置的 expire 为<code>null</code> ，但并没有自行处理过期的任务，导致过期的任务得不到处理，且一直占用消息队列的空间。</p></li><li><p><strong>3.7.6</strong> 配置的 expire <code>不为null</code> ，但配置的 expire 时间太短，以至于 expire 时间 &lt; 消费者的 <code>fire()</code> 方法所需时间 + 删除该任务所需的时间 ，那么任务将被误认为执行超时，从而被消息队列还原为待执行状态。</p></li><li><p><strong>3.7.7</strong> 使用 <code>Queue::push($jobHandlerClassName , $jobData, $jobQueueName );</code> 推送任务时，<code>$jobData</code> 中包含未序列化的对象。这时，在消费者端拿到的 <code>$jobData</code> 中拿到的是该对象的public 属性的键值对数组。因此，需要在推送前手动序列化对象，在消费者端再手动反序列化还原为对象。</p></li></ul><h2 id=四-拓展><a href=#四-拓展 class=headerlink title="四 拓展"></a>四 拓展</h2><h3 id=4-1-队列的稳定性和拓展性><a href=#4-1-队列的稳定性和拓展性 class=headerlink title="4.1 队列的稳定性和拓展性"></a>4.1 队列的稳定性和拓展性</h3><ul><li>稳定性：不管是 listen 模式还是 work 模式，都建议使用 supervisor 或者 自定义的cron 脚本，去定时检查 work 进程是否正常</li><li>拓展性： 当某个队列的消费者不足时，再给这个队列添加 work进程即可。</li></ul><h3 id=4-2-消息队列的可视化管理工具><a href=#4-2-消息队列的可视化管理工具 class=headerlink title="4.2 消息队列的可视化管理工具"></a>4.2 消息队列的可视化管理工具</h3><ul><li>队列管理，队列的列表，队列的 work 进程数量控制，队列的任务数量变化趋势 //TBD</li><li>任务管理，任务的列表，添加/<strong>撤回</strong>/查询任务，修改任务的 执行者/执行时间/优先级/数据 等 //TBD</li></ul><h3 id=4-2-编写自定义的-thinkphp-queue-驱动><a href=#4-2-编写自定义的-thinkphp-queue-驱动 class=headerlink title="4.2 编写自定义的 thinkphp-queue 驱动"></a>4.2 编写自定义的 thinkphp-queue 驱动</h3><p>//TBD</p><h3 id=4-3-编写消息队列的单元测试><a href=#4-3-编写消息队列的单元测试 class=headerlink title="4.3 编写消息队列的单元测试"></a>4.3 编写消息队列的单元测试</h3><p>//TBD</p><h3 id=4-4-与其他PHP消息队列库的对比><a href=#4-4-与其他PHP消息队列库的对比 class=headerlink title="4.4 与其他PHP消息队列库的对比"></a>4.4 与其他PHP消息队列库的对比</h3><p>TP5的消息队列与Laravel的消息队列比较相似，下面是与laravel 中的消息队列的一些对比：</p><figure class="highlight lsl"><table><tr><td class=gutter><pre><div class=line>1</div></pre></td><td class=code><pre><div class=line>| thinkphp-queue (v1<span class=number>.1</span><span class=number>.2</span>)             | laravel-queue (v5<span class=number>.3</span>)</div></pre></td></tr></table></figure><p>——— | ———————————– | ————————————— 内置的驱动 | Database，Redis，Sync，TopThink | Database，Redis, Sync(在laravel中称为 null)。 Redis驱动要求 | 安装redis的C扩展 | 安装 predis 包 + LUA脚本 推送任务 | 允许推送 消费者类名，消费者对象 | 允许推送消费者类名，消费者对象，闭包 失败任务处理 | 触发失败回调事件 (有Bug) | 触发失败回调事件 + 移动任务到 failed_jobs表? 消息订阅 | subscribe 命令+ Topthink驱动(注：未实现/未提供) | subscribe 命令 + 安装IronMQ 驱动 删除任务 | 消费者类中手动删除 | 任务完成后自动删除 推送到多个队列 | 需自己实现 | 原生支持 延迟执行 | 支持 (有Bug) | 支持 消息重发 | 支持 | 支持 检查已执行次数 | 原生支持 | 需在消费者类中显式 use 相关的 trait 执行方式 | work 模式 + listen 模式 | work 模式 + listen 模式 进程命令 | 开启，停止，重启 | 开启，停止，重启 任务命令 | 无 | 展示失败任务列表，重试某个失败任务，删除某个失败任务 支持的事件 | 失败回调事件 | 失败回调事件，支持消费前事件，消费后事件</p><hr><p>使用supervisor管理think-queue示例</p><p>配置文件 /etc/supervisord.conf 末尾添加以下代码：</p><figure class="highlight sh"><table><tr><td class=gutter><pre><div class=line>1</div><div class=line>2</div><div class=line>3</div><div class=line>4</div><div class=line>5</div><div class=line>6</div><div class=line>7</div><div class=line>8</div><div class=line>9</div><div class=line>10</div><div class=line>11</div></pre></td><td class=code><pre><div class=line>[program:php]</div><div class=line><span class=built_in>command</span>= /usr/bin/php think queue:work --queue notify --daemon ; 被监控进程</div><div class=line>directory=/home/wwwroot/dlsj.mrpzx.com</div><div class=line>;process_name=%(process_num)02d</div><div class=line>;numprocs=5 <span class=comment>#启动几个进程</span></div><div class=line>autostart=<span class=literal>true</span> ;随着supervisord的启动而启动</div><div class=line>autorestart=<span class=literal>true</span> ;自动启动</div><div class=line>startsecs=1 ;程序重启时候停留在runing状态的秒数</div><div class=line>startretries=10 ;启动失败时的最多重试次数</div><div class=line>redirect_stderr=<span class=literal>true</span> ;重定向stderr到stdout</div><div class=line>stdout_logfile=/root/supervisor.log ;stdout文件</div></pre></td></tr></table></figure><p>复制代码 值得注意的是 每行的 ; 要跟前面的命令用空格隔开， 不能挨着， 然后注释文字要以;开头， 不能#开头 ，每行 ; 作为命令的结尾</p></div><div id=side-right-bar><div class=close-right-bar></div><div class=sidebar-toc><div class=sidebar-toc__title>目录</div><div class=sidebar-toc__progress><span class=progress-notice>你已经阅读了</span><span class=progress-num>0</span><span class=progress-percentage>%</span><div class=sidebar-toc__progress-bar></div></div><div class=sidebar-toc__content><ol class=toc><li class="toc-item toc-level-1"><a class=toc-link href=#安装supervisor><span class=toc-number>1.</span> <span class=toc-text>安装supervisor</span></a><ol class=toc-child><li class="toc-item toc-level-2"><a class=toc-link href=#1-获取supervisor包：【https-pypi-python-org-pypi-supervisor】><span class=toc-number>1.1.</span> <span class=toc-text>1.获取supervisor包：【https://pypi.python.org/pypi/supervisor】</span></a></li><li class="toc-item toc-level-2"><a class=toc-link href=#2-解压supervisor-3-3-1-tar-gz-并安装><span class=toc-number>1.2.</span> <span class=toc-text>2.解压supervisor-3.3.1.tar.gz 并安装</span></a></li><li class="toc-item toc-level-2"><a class=toc-link href=#3-创建supervisor的配置文件：><span class=toc-number>1.3.</span> <span class=toc-text>3.创建supervisor的配置文件：</span></a></li><li class="toc-item toc-level-2"><a class=toc-link href=#4-开启supervisord服务><span class=toc-number>1.4.</span> <span class=toc-text>4.开启supervisord服务</span></a></li><li class="toc-item toc-level-2"><a class=toc-link href=#5-更新新的配置到supervisord><span class=toc-number>1.5.</span> <span class=toc-text>5.更新新的配置到supervisord</span></a></li><li class="toc-item toc-level-2"><a class=toc-link href=#6-重新启动配置中的所有程序><span class=toc-number>1.6.</span> <span class=toc-text>6.重新启动配置中的所有程序</span></a></li><li class="toc-item toc-level-2"><a class=toc-link href=#7-启动某个进程-program-name-你配置中写的程序名称><span class=toc-number>1.7.</span> <span class=toc-text>7.启动某个进程(program_name=你配置中写的程序名称)</span></a></li><li class="toc-item toc-level-2"><a class=toc-link href=#8-查看正在守候的进程><span class=toc-number>1.8.</span> <span class=toc-text>8.查看正在守候的进程</span></a></li><li class="toc-item toc-level-2"><a class=toc-link href=#9-重启某一进程-program-name-你配置中写的程序名称><span class=toc-number>1.9.</span> <span class=toc-text>9.重启某一进程 (program_name=你配置中写的程序名称)</span></a></li><li class="toc-item toc-level-2"><a class=toc-link href=#10-停止全部进程><span class=toc-number>1.10.</span> <span class=toc-text>10.停止全部进程</span></a></li><li class="toc-item toc-level-2"><a class=toc-link href=#11-查看supervisord进程><span class=toc-number>1.11.</span> <span class=toc-text>11.查看supervisord进程</span></a><ol class=toc-child><li class="toc-item toc-level-3"><a class=toc-link href=#一-代码示例><span class=toc-number>1.11.1.</span> <span class=toc-text>一 代码示例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class=toc-link href=#安装-thinkphp-queue><span class=toc-number>2.</span> <span class=toc-text>安装 thinkphp-queue</span></a><ol class=toc-child><li class="toc-item toc-level-2"><a class=toc-link href=#搭建消息队列的存储环境><span class=toc-number>2.1.</span> <span class=toc-text>搭建消息队列的存储环境</span></a></li><li class="toc-item toc-level-2"><a class=toc-link href=#配置消息队列的驱动><span class=toc-number>2.2.</span> <span class=toc-text>配置消息队列的驱动</span></a><ol class=toc-child><li class="toc-item toc-level-3"><a class=toc-link href=#消息的创建与推送><span class=toc-number>2.2.1.</span> <span class=toc-text>消息的创建与推送</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#消息的消费与删除><span class=toc-number>2.2.2.</span> <span class=toc-text>消息的消费与删除</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#发布任务><span class=toc-number>2.2.3.</span> <span class=toc-text>发布任务</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#处理任务><span class=toc-number>2.2.4.</span> <span class=toc-text>处理任务</span></a></li></ol></li><li class="toc-item toc-level-2"><a class=toc-link href=#二-详细介绍><span class=toc-number>2.3.</span> <span class=toc-text>二 详细介绍</span></a><ol class=toc-child><li class="toc-item toc-level-3"><a class=toc-link href=#2-1-命令模式><span class=toc-number>2.3.1.</span> <span class=toc-text>2.1 命令模式</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#2-2-命令行参数><span class=toc-number>2.3.2.</span> <span class=toc-text>2.2 命令行参数</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#2-3-work-模式和-listen-模式的区别><span class=toc-number>2.3.3.</span> <span class=toc-text>2.3 work 模式和 listen 模式的区别</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#2-4-消息队列的开始，停止与重启><span class=toc-number>2.3.4.</span> <span class=toc-text>2.4 消息队列的开始，停止与重启</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#2-5-多模块，多任务的处理><span class=toc-number>2.3.5.</span> <span class=toc-text>2.5 多模块，多任务的处理</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#2-6-消息的延迟执行与定时执行><span class=toc-number>2.3.6.</span> <span class=toc-text>2.6 消息的延迟执行与定时执行</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#2-7-消息的重发><span class=toc-number>2.3.7.</span> <span class=toc-text>2.7 消息的重发</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#2-8-任务的失败回调及告警><span class=toc-number>2.3.8.</span> <span class=toc-text>2.8 任务的失败回调及告警</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#2-9-处理过期的任务><span class=toc-number>2.3.9.</span> <span class=toc-text>2.9 处理过期的任务</span></a></li></ol></li><li class="toc-item toc-level-2"><a class=toc-link href=#三-深入理解><span class=toc-number>2.4.</span> <span class=toc-text>三 深入理解</span></a><ol class=toc-child><li class="toc-item toc-level-3"><a class=toc-link href=#3-1-thinkphp-queue-中消息与队列的保存方式><span class=toc-number>2.4.1.</span> <span class=toc-text>3.1 thinkphp-queue 中消息与队列的保存方式</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#3-2-thinkphp-queue-的目录结构和类关系图><span class=toc-number>2.4.2.</span> <span class=toc-text>3.2 thinkphp-queue 的目录结构和类关系图</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#3-3-Deamon模式的执行流程><span class=toc-number>2.4.3.</span> <span class=toc-text>3.3 Deamon模式的执行流程</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#3-4-Database模式下消息处理的详细流程><span class=toc-number>2.4.4.</span> <span class=toc-text>3.4 Database模式下消息处理的详细流程</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#3-5-redis-驱动下的任务重发细节><span class=toc-number>2.4.5.</span> <span class=toc-text>3.5 redis 驱动下的任务重发细节</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#3-6-thinkphp-queue的性能><span class=toc-number>2.4.6.</span> <span class=toc-text>3.6 thinkphp-queue的性能</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#3-7-thinkphp-queue-的N种错误使用姿势><span class=toc-number>2.4.7.</span> <span class=toc-text>3.7 thinkphp-queue 的N种错误使用姿势</span></a></li></ol></li><li class="toc-item toc-level-2"><a class=toc-link href=#四-拓展><span class=toc-number>2.5.</span> <span class=toc-text>四 拓展</span></a><ol class=toc-child><li class="toc-item toc-level-3"><a class=toc-link href=#4-1-队列的稳定性和拓展性><span class=toc-number>2.5.1.</span> <span class=toc-text>4.1 队列的稳定性和拓展性</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#4-2-消息队列的可视化管理工具><span class=toc-number>2.5.2.</span> <span class=toc-text>4.2 消息队列的可视化管理工具</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#4-2-编写自定义的-thinkphp-queue-驱动><span class=toc-number>2.5.3.</span> <span class=toc-text>4.2 编写自定义的 thinkphp-queue 驱动</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#4-3-编写消息队列的单元测试><span class=toc-number>2.5.4.</span> <span class=toc-text>4.3 编写消息队列的单元测试</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#4-4-与其他PHP消息队列库的对比><span class=toc-number>2.5.5.</span> <span class=toc-text>4.4 与其他PHP消息队列库的对比</span></a></li></ol></li></ol></li></ol></div></div></div><div class=right-btn id=right-btn><span>目录</span></div><div class=article-bottom><div class="addthis_inline_share_toolbox fr"></div></div><div class=post-copyright><div class=post-copyright__author><span class=post-copyright-meta>文章作者:</span><span class=post-copyright-info><a href=mailto:undefined>CavinHuang</a></span></div><div class=post-copyright__type><span class=post-copyright-meta>文章链接:</span><span class=post-copyright-info><a href="http://blog.zukmb.cncentos7结合supervisor和think-queue实现队列/">http://blog.zukmb.cncentos7结合supervisor和think-queue实现队列/</a></span></div><div class=post-copyright__notice><span class=post-copyright-meta>版权声明:</span><span class=post-copyright-info>转载请注明来自<a href=http://blog.zukmb.cn target=_blank style="font-size: 18px;">CavinHuangのBlog</a>！</span></div></div><div class=article-pagenate><div class="article-prev fl"><span>←</span><a href="/记录一次win10-deepin双系统安装过程/">记录一次win10+deepin双系统安装过程</a></div><div class="article-next fr"><a href="/记一次linux超级用户和普通用户出现的差错/">记一次linux超级用户和普通用户出现的差错</a><span>→</span></div></div></article></div><footer class=footer><div id=toTop style="display: none;">Back to Top</div></footer></div></div><canvas class=fireworks></canvas><script src=/js/velocity.ui.min.js></script><script src=/js/yoyo.js></script><script src=/js/scroll.js></script><script src=/js/particle.js></script><script src=/js/anime.min.js></script><script src=/js/fireworks.js></script>